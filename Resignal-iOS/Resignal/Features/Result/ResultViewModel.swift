//
//  ResultViewModel.swift
//  Resignal
//
//  ViewModel for the analysis result screen.
//

import Foundation
import SwiftUI

/// Enum representing expandable feedback sections
enum FeedbackSection: String, CaseIterable, Hashable {
    case summary
    case strengths
    case weaknesses
    case suggested
    case followUp
}

/// ViewModel managing the result screen state
@MainActor
@Observable
final class ResultViewModel: ResultViewModelProtocol {
    
    // MARK: - Properties
    
    private let aiClient: any AIClient
    private let sessionRepository: SessionRepositoryProtocol
    
    let session: Session
    var sections: FeedbackSections
    var regenerateState: ViewState<FeedbackSections> = .idle
    var showShareSheet: Bool = false
    
    // Expansion states using Set
    var expandedSections: Set<FeedbackSection> = [.summary, .strengths, .weaknesses]
    
    // MARK: - Computed Properties
    
    var isRegenerating: Bool {
        regenerateState.isLoading
    }
    
    var errorMessage: String? {
        regenerateState.error
    }
    
    var showError: Bool {
        get { regenerateState.hasError }
        set { if !newValue { clearError() } }
    }
    
    var shareText: String {
        """
        Interview Analysis - \(session.displayTitle)
        Date: \(session.createdAt.mediumFormatted)
        \(session.role.map { "Role: \($0)\n" } ?? "")
        ---
        
        \(session.outputFeedback)
        
        ---
        Generated by Resignal
        """
    }
    
    // MARK: - Initialization
    
    init(
        session: Session,
        aiClient: any AIClient,
        sessionRepository: SessionRepositoryProtocol
    ) {
        self.session = session
        self.aiClient = aiClient
        self.sessionRepository = sessionRepository
        self.sections = FeedbackParser.parse(session.outputFeedback)
    }
    
    // MARK: - Public Methods
    
    /// Checks if a section is expanded
    func isExpanded(_ section: FeedbackSection) -> Bool {
        expandedSections.contains(section)
    }
    
    /// Toggles the expansion state of a section
    func toggleExpansion(_ section: FeedbackSection) {
        if expandedSections.contains(section) {
            expandedSections.remove(section)
        } else {
            expandedSections.insert(section)
        }
    }
    
    /// Returns a binding for section expansion
    func expansionBinding(for section: FeedbackSection) -> Binding<Bool> {
        Binding(
            get: { self.isExpanded(section) },
            set: { _ in self.toggleExpansion(section) }
        )
    }
    
    /// Regenerates the analysis
    func regenerate() async {
        regenerateState = .loading
        
        do {
            let request = AnalysisRequest(
                inputText: session.inputText,
                role: session.role,
                rubric: session.rubricType
            )
            
            let response = try await aiClient.analyze(request)
            
            // Update session
            session.outputFeedback = response.feedback
            session.version += 1
            try sessionRepository.update(session, title: nil, tags: nil)
            
            // Parse new feedback
            sections = FeedbackParser.parse(response.feedback)
            regenerateState = .success(sections)
            
        } catch let error as AIClientError {
            regenerateState = .error(error.localizedDescription)
            debugLog("Regenerate error: \(error)")
        } catch {
            regenerateState = .error("An unexpected error occurred.")
            debugLog("Unexpected error: \(error)")
        }
    }
    
    /// Copies feedback to clipboard
    func copyToClipboard() {
        UIPasteboard.general.string = session.outputFeedback
    }
    
    /// Clears any error state
    func clearError() {
        if regenerateState.hasError {
            regenerateState = .idle
        }
    }
    
    // MARK: - Private Methods

    private func debugLog(_ message: String) {
        #if DEBUG
        print("[ResultViewModel] \(message)")
        #endif
    }
}
