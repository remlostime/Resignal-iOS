//
//  ResultViewModel.swift
//  Resignal
//
//  ViewModel for the analysis result screen.
//

import Foundation
import SwiftUI

/// Parsed sections from the AI feedback
struct FeedbackSections: Sendable {
    var summary: String = ""
    var strengths: String = ""
    var weaknesses: String = ""
    var suggestedAnswers: String = ""
    var followUpQuestions: String = ""
    var raw: String = ""
}

/// ViewModel managing the result screen state
@MainActor
@Observable
final class ResultViewModel {
    
    // MARK: - Properties
    
    private let aiClient: any AIClient
    private let sessionRepository: SessionRepositoryProtocol
    
    let session: Session
    var sections: FeedbackSections
    var isRegenerating: Bool = false
    var errorMessage: String?
    var showError: Bool = false
    var showShareSheet: Bool = false
    
    // Expansion states
    var isSummaryExpanded: Bool = true
    var isStrengthsExpanded: Bool = true
    var isWeaknessesExpanded: Bool = true
    var isSuggestedExpanded: Bool = false
    var isFollowUpExpanded: Bool = false
    
    // MARK: - Computed Properties
    
    var shareText: String {
        """
        Interview Analysis - \(session.displayTitle)
        Date: \(session.createdAt.mediumFormatted)
        \(session.role.map { "Role: \($0)\n" } ?? "")
        ---
        
        \(session.outputFeedback)
        
        ---
        Generated by Resignal
        """
    }
    
    // MARK: - Initialization
    
    init(
        session: Session,
        aiClient: any AIClient,
        sessionRepository: SessionRepositoryProtocol
    ) {
        self.session = session
        self.aiClient = aiClient
        self.sessionRepository = sessionRepository
        self.sections = Self.parseFeedback(session.outputFeedback)
    }
    
    // MARK: - Public Methods
    
    /// Regenerates the analysis
    func regenerate() async {
        isRegenerating = true
        errorMessage = nil
        
        do {
            let request = AnalysisRequest(
                inputText: session.inputText,
                role: session.role,
                rubric: session.rubricType
            )
            
            let response = try await aiClient.analyze(request)
            
            // Update session
            session.outputFeedback = response.feedback
            session.version += 1
            try sessionRepository.update(session, title: nil, tags: nil)
            
            // Parse new feedback
            sections = Self.parseFeedback(response.feedback)
            
            isRegenerating = false
            
        } catch let error as AIClientError {
            errorMessage = error.localizedDescription
            showError = true
            isRegenerating = false
            debugLog("Regenerate error: \(error)")
        } catch {
            errorMessage = "An unexpected error occurred."
            showError = true
            isRegenerating = false
            debugLog("Unexpected error: \(error)")
        }
    }
    
    /// Copies feedback to clipboard
    func copyToClipboard() {
        UIPasteboard.general.string = session.outputFeedback
    }
    
    // MARK: - Private Methods
    
    private static func parseFeedback(_ feedback: String) -> FeedbackSections {
        var sections = FeedbackSections()
        sections.raw = feedback
        
        // Parse markdown sections
        let patterns: [(String, WritableKeyPath<FeedbackSections, String>)] = [
            ("## Summary", \.summary),
            ("## Strengths", \.strengths),
            ("## Weaknesses", \.weaknesses),
            ("## Suggested Improved Answers", \.suggestedAnswers),
            ("## Follow-up Questions", \.followUpQuestions)
        ]
        
        for (index, (header, keyPath)) in patterns.enumerated() {
            if let startRange = feedback.range(of: header) {
                let startIndex = feedback.index(startRange.upperBound, offsetBy: 0)
                
                // Find the end (next header or end of string)
                var endIndex = feedback.endIndex
                for nextIndex in (index + 1)..<patterns.count {
                    if let nextRange = feedback.range(of: patterns[nextIndex].0) {
                        endIndex = nextRange.lowerBound
                        break
                    }
                }
                
                let content = String(feedback[startIndex..<endIndex])
                    .trimmingCharacters(in: .whitespacesAndNewlines)
                sections[keyPath: keyPath] = content
            }
        }
        
        return sections
    }
    
    private func debugLog(_ message: String) {
        #if DEBUG
        print("[ResultViewModel] \(message)")
        #endif
    }
}

